// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package photo_library

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPhotoIDToGroup = `-- name: AddPhotoIDToGroup :exec
INSERT INTO photo_groups_photos (photo_id, group_id)
VALUES ($1, $2)
`

type AddPhotoIDToGroupParams struct {
	PhotoID uuid.UUID
	GroupID uuid.UUID
}

func (q *Queries) AddPhotoIDToGroup(ctx context.Context, arg AddPhotoIDToGroupParams) error {
	_, err := q.db.Exec(ctx, addPhotoIDToGroup, arg.PhotoID, arg.GroupID)
	return err
}

const addPhotoProcessing = `-- name: AddPhotoProcessing :exec

INSERT INTO photo_processing (photo_id, processed_at, type, success)
VALUES ($1, $2, $3, $4)
`

type AddPhotoProcessingParams struct {
	PhotoID     uuid.UUID
	ProcessedAt time.Time
	Type        ProcessingType
	Success     bool
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) AddPhotoProcessing(ctx context.Context, arg AddPhotoProcessingParams) error {
	_, err := q.db.Exec(ctx, addPhotoProcessing,
		arg.PhotoID,
		arg.ProcessedAt,
		arg.Type,
		arg.Success,
	)
	return err
}

const deleteApiToken = `-- name: DeleteApiToken :one
DELETE FROM api_tokens
WHERE id=$1 and person_id=$2
RETURNING id
`

type DeleteApiTokenParams struct {
	ID       uuid.UUID
	PersonID uuid.UUID
}

func (q *Queries) DeleteApiToken(ctx context.Context, arg DeleteApiTokenParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteApiToken, arg.ID, arg.PersonID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteCoefficientSimilarPhoto = `-- name: DeleteCoefficientSimilarPhoto :exec
DELETE FROM coefficients_similar_photos
WHERE photo_id1 = $1 OR photo_id2 = $1
`

func (q *Queries) DeleteCoefficientSimilarPhoto(ctx context.Context, photoId1 uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCoefficientSimilarPhoto, photoId1)
	return err
}

const deleteExif = `-- name: DeleteExif :one
DELETE FROM exif_photo_data
WHERE photo_id=$1
RETURNING photo_id
`

func (q *Queries) DeleteExif(ctx context.Context, photoID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteExif, photoID)
	var photo_id uuid.UUID
	err := row.Scan(&photo_id)
	return photo_id, err
}

const deleteMetadata = `-- name: DeleteMetadata :one
DELETE FROM meta_photo_data
WHERE photo_id=$1
RETURNING photo_id
`

func (q *Queries) DeleteMetadata(ctx context.Context, photoID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteMetadata, photoID)
	var photo_id uuid.UUID
	err := row.Scan(&photo_id)
	return photo_id, err
}

const deletePhotoGroup = `-- name: DeletePhotoGroup :one
DELETE FROM photo_groups where id = $1  RETURNING id
`

func (q *Queries) DeletePhotoGroup(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deletePhotoGroup, id)
	err := row.Scan(&id)
	return id, err
}

const deletePhotoGroupByMainPhoto = `-- name: DeletePhotoGroupByMainPhoto :exec
DELETE FROM photo_groups where main_photo_id = $1
`

func (q *Queries) DeletePhotoGroupByMainPhoto(ctx context.Context, mainPhotoID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePhotoGroupByMainPhoto, mainPhotoID)
	return err
}

const deletePhotoGroupPhotos = `-- name: DeletePhotoGroupPhotos :exec
DELETE FROM photo_groups_photos where group_id = $1
`

func (q *Queries) DeletePhotoGroupPhotos(ctx context.Context, groupID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePhotoGroupPhotos, groupID)
	return err
}

const deletePhotoGroupPhotosByPhoto = `-- name: DeletePhotoGroupPhotosByPhoto :exec
DELETE FROM photo_groups_photos where photo_id = $1
`

func (q *Queries) DeletePhotoGroupPhotosByPhoto(ctx context.Context, photoID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePhotoGroupPhotosByPhoto, photoID)
	return err
}

const deletePhotoPreviews = `-- name: DeletePhotoPreviews :exec
DELETE FROM photo_previews
WHERE photo_id=$1
`

func (q *Queries) DeletePhotoPreviews(ctx context.Context, photoID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePhotoPreviews, photoID)
	return err
}

const deletePhotoTagsByCategories = `-- name: DeletePhotoTagsByCategories :one
DELETE FROM photo_tags
WHERE photo_id=$1 and category_id = ANY ($2::uuid[]) -- IN (sqlc.slice(category_ids)::uuid[])
RETURNING photo_id
`

type DeletePhotoTagsByCategoriesParams struct {
	PhotoID     uuid.UUID
	CategoryIds []uuid.UUID
}

func (q *Queries) DeletePhotoTagsByCategories(ctx context.Context, arg DeletePhotoTagsByCategoriesParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deletePhotoTagsByCategories, arg.PhotoID, arg.CategoryIds)
	var photo_id uuid.UUID
	err := row.Scan(&photo_id)
	return photo_id, err
}

const deletePhotoVector = `-- name: DeletePhotoVector :one
DELETE FROM photo_vectors
WHERE photo_id=$1
RETURNING photo_id
`

func (q *Queries) DeletePhotoVector(ctx context.Context, photoID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deletePhotoVector, photoID)
	var photo_id uuid.UUID
	err := row.Scan(&photo_id)
	return photo_id, err
}

const deleteTag = `-- name: DeleteTag :one
DELETE FROM photo_tags
WHERE id=$1
RETURNING id
`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteTag, id)
	err := row.Scan(&id)
	return id, err
}

const emailExists = `-- name: EmailExists :one
SELECT count(1) as count FROM auth WHERE email = $1
`

func (q *Queries) EmailExists(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, emailExists, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const findCoefficientSimilarPhoto = `-- name: FindCoefficientSimilarPhoto :many
SELECT photo_id1, photo_id2, coefficient
FROM coefficients_similar_photos
WHERE photo_id1 = $1 OR photo_id2 = $1
`

func (q *Queries) FindCoefficientSimilarPhoto(ctx context.Context, photoId1 uuid.UUID) ([]CoefficientsSimilarPhoto, error) {
	rows, err := q.db.Query(ctx, findCoefficientSimilarPhoto, photoId1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoefficientsSimilarPhoto
	for rows.Next() {
		var i CoefficientsSimilarPhoto
		if err := rows.Scan(&i.PhotoId1, &i.PhotoId2, &i.Coefficient); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findGroupIDByPhotoID = `-- name: FindGroupIDByPhotoID :one

SELECT group_id
FROM photo_groups_photos
WHERE photo_id = $1
LIMIT 1
`

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) FindGroupIDByPhotoID(ctx context.Context, photoID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, findGroupIDByPhotoID, photoID)
	var group_id uuid.UUID
	err := row.Scan(&group_id)
	return group_id, err
}

const getActiveConfirmCode = `-- name: GetActiveConfirmCode :one
SELECT code, person_id, created_at, updated_at, active, type FROM codes
WHERE code = $1 AND type = $2 and active = true
`

type GetActiveConfirmCodeParams struct {
	Code string
	Type CodeType
}

func (q *Queries) GetActiveConfirmCode(ctx context.Context, arg GetActiveConfirmCodeParams) (Code, error) {
	row := q.db.QueryRow(ctx, getActiveConfirmCode, arg.Code, arg.Type)
	var i Code
	err := row.Scan(
		&i.Code,
		&i.PersonID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Active,
		&i.Type,
	)
	return i, err
}

const getApiToken = `-- name: GetApiToken :one
SELECT id, person_id, caption, token, created_at, updated_at, expired_at, type FROM api_tokens
WHERE token=$1
LIMIT 1
`

func (q *Queries) GetApiToken(ctx context.Context, token string) (ApiToken, error) {
	row := q.db.QueryRow(ctx, getApiToken, token)
	var i ApiToken
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.Caption,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
		&i.Type,
	)
	return i, err
}

const getApiTokens = `-- name: GetApiTokens :many

SELECT id, person_id, caption, token, created_at, updated_at, expired_at, type FROM api_tokens
WHERE person_id=$1
ORDER BY created_at
`

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetApiTokens(ctx context.Context, personID uuid.UUID) ([]ApiToken, error) {
	rows, err := q.db.Query(ctx, getApiTokens, personID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiToken
	for rows.Next() {
		var i ApiToken
		if err := rows.Scan(
			&i.ID,
			&i.PersonID,
			&i.Caption,
			&i.Token,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiredAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuth = `-- name: GetAuth :one
SELECT person_id, created_at, updated_at, email, password_hash, status, role FROM auth WHERE person_id = $1
`

func (q *Queries) GetAuth(ctx context.Context, personID uuid.UUID) (Auth, error) {
	row := q.db.QueryRow(ctx, getAuth, personID)
	var i Auth
	err := row.Scan(
		&i.PersonID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.PasswordHash,
		&i.Status,
		&i.Role,
	)
	return i, err
}

const getAuthByEmail = `-- name: GetAuthByEmail :one
SELECT person_id, created_at, updated_at, email, password_hash, status, role FROM auth WHERE email = $1
`

func (q *Queries) GetAuthByEmail(ctx context.Context, email string) (Auth, error) {
	row := q.db.QueryRow(ctx, getAuthByEmail, email)
	var i Auth
	err := row.Scan(
		&i.PersonID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.PasswordHash,
		&i.Status,
		&i.Role,
	)
	return i, err
}

const getExif = `-- name: GetExif :one
SELECT photo_id, data FROM exif_photo_data
WHERE photo_id=$1
LIMIT 1
`

func (q *Queries) GetExif(ctx context.Context, photoID uuid.UUID) (ExifPhotoDatum, error) {
	row := q.db.QueryRow(ctx, getExif, photoID)
	var i ExifPhotoDatum
	err := row.Scan(&i.PhotoID, &i.Data)
	return i, err
}

const getGeoAddress = `-- name: GetGeoAddress :one
SELECT photo_id, created_at, geo_latitude, geo_longitude,
       formatted_address, street, house_number, suburb,
       postcode, state, state_code, state_district, county,
       country, country_code, city
FROM photo_locations WHERE photo_id = $1
`

func (q *Queries) GetGeoAddress(ctx context.Context, photoID uuid.UUID) (PhotoLocation, error) {
	row := q.db.QueryRow(ctx, getGeoAddress, photoID)
	var i PhotoLocation
	err := row.Scan(
		&i.PhotoID,
		&i.CreatedAt,
		&i.GeoLatitude,
		&i.GeoLongitude,
		&i.FormattedAddress,
		&i.Street,
		&i.HouseNumber,
		&i.Suburb,
		&i.Postcode,
		&i.State,
		&i.StateCode,
		&i.StateDistrict,
		&i.County,
		&i.Country,
		&i.CountryCode,
		&i.City,
	)
	return i, err
}

const getGroupByID = `-- name: GetGroupByID :many
SELECT id, main_photo_id, updated_at, created_at, p.photo_id as photo_id
FROM photo_groups
LEFT JOIN photo_groups_photos p ON photo_groups.id = p.group_id
WHERE id = $1
`

type GetGroupByIDRow struct {
	ID          uuid.UUID
	MainPhotoID uuid.UUID
	UpdatedAt   time.Time
	CreatedAt   time.Time
	PhotoID     pgtype.UUID
}

func (q *Queries) GetGroupByID(ctx context.Context, id uuid.UUID) ([]GetGroupByIDRow, error) {
	rows, err := q.db.Query(ctx, getGroupByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupByIDRow
	for rows.Next() {
		var i GetGroupByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.MainPhotoID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.PhotoID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupPhotoIDs = `-- name: GetGroupPhotoIDs :many
SELECT photo_id
FROM photo_groups_photos
WHERE group_id = $1
`

func (q *Queries) GetGroupPhotoIDs(ctx context.Context, groupID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getGroupPhotoIDs, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var photo_id uuid.UUID
		if err := rows.Scan(&photo_id); err != nil {
			return nil, err
		}
		items = append(items, photo_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastActiveRefreshToken = `-- name: GetLastActiveRefreshToken :one
SELECT id, person_id, created_at, updated_at, status FROM refresh_codes
WHERE id=$1 and status='ACTIVE'
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLastActiveRefreshToken(ctx context.Context, id uuid.UUID) (RefreshCode, error) {
	row := q.db.QueryRow(ctx, getLastActiveRefreshToken, id)
	var i RefreshCode
	err := row.Scan(
		&i.ID,
		&i.PersonID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getMetadata = `-- name: GetMetadata :one
SELECT photo_id, model_info, size_bytes, width_pixel, height_pixel,
       date_time, updated_at, geo_latitude, geo_longitude FROM meta_photo_data
WHERE photo_id=$1
LIMIT 1
`

func (q *Queries) GetMetadata(ctx context.Context, photoID uuid.UUID) (MetaPhotoDatum, error) {
	row := q.db.QueryRow(ctx, getMetadata, photoID)
	var i MetaPhotoDatum
	err := row.Scan(
		&i.PhotoID,
		&i.ModelInfo,
		&i.SizeBytes,
		&i.WidthPixel,
		&i.HeightPixel,
		&i.DateTime,
		&i.UpdatedAt,
		&i.GeoLatitude,
		&i.GeoLongitude,
	)
	return i, err
}

const getPaginatedPhotoGroups = `-- name: GetPaginatedPhotoGroups :many
SELECT id, main_photo_id, updated_at, created_at, p.photo_id as photo_id FROM photo_groups
LEFT JOIN photo_groups_photos p ON photo_groups.id = p.group_id
OFFSET $1 LIMIT $2
`

type GetPaginatedPhotoGroupsParams struct {
	Offset int32
	Limit  int32
}

type GetPaginatedPhotoGroupsRow struct {
	ID          uuid.UUID
	MainPhotoID uuid.UUID
	UpdatedAt   time.Time
	CreatedAt   time.Time
	PhotoID     pgtype.UUID
}

func (q *Queries) GetPaginatedPhotoGroups(ctx context.Context, arg GetPaginatedPhotoGroupsParams) ([]GetPaginatedPhotoGroupsRow, error) {
	rows, err := q.db.Query(ctx, getPaginatedPhotoGroups, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPaginatedPhotoGroupsRow
	for rows.Next() {
		var i GetPaginatedPhotoGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.MainPhotoID,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.PhotoID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPeopleCount = `-- name: GetPeopleCount :one
SELECT count(1) as count FROM people
`

func (q *Queries) GetPeopleCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getPeopleCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPerson = `-- name: GetPerson :one
SELECT id, created_at, updated_at, firstname, surname, patronymic FROM people WHERE id = $1
`

func (q *Queries) GetPerson(ctx context.Context, id uuid.UUID) (Person, error) {
	row := q.db.QueryRow(ctx, getPerson, id)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Firstname,
		&i.Surname,
		&i.Patronymic,
	)
	return i, err
}

const getPhotoByFileKey = `-- name: GetPhotoByFileKey :one
SELECT id, file_key, hash, photo_updated_at, extension
FROM photos
WHERE file_key = $1 AND status = 'ACTIVE'
LIMIT 1
`

type GetPhotoByFileKeyRow struct {
	ID             uuid.UUID
	FileKey        string
	Hash           string
	PhotoUpdatedAt time.Time
	Extension      PhotoExtension
}

func (q *Queries) GetPhotoByFileKey(ctx context.Context, fileKey string) (GetPhotoByFileKeyRow, error) {
	row := q.db.QueryRow(ctx, getPhotoByFileKey, fileKey)
	var i GetPhotoByFileKeyRow
	err := row.Scan(
		&i.ID,
		&i.FileKey,
		&i.Hash,
		&i.PhotoUpdatedAt,
		&i.Extension,
	)
	return i, err
}

const getPhotoByHash = `-- name: GetPhotoByHash :one
SELECT id, file_key, hash, photo_updated_at, extension
FROM photos
WHERE hash = $1 AND status = 'ACTIVE'
LIMIT 1
`

type GetPhotoByHashRow struct {
	ID             uuid.UUID
	FileKey        string
	Hash           string
	PhotoUpdatedAt time.Time
	Extension      PhotoExtension
}

func (q *Queries) GetPhotoByHash(ctx context.Context, hash string) (GetPhotoByHashRow, error) {
	row := q.db.QueryRow(ctx, getPhotoByHash, hash)
	var i GetPhotoByHashRow
	err := row.Scan(
		&i.ID,
		&i.FileKey,
		&i.Hash,
		&i.PhotoUpdatedAt,
		&i.Extension,
	)
	return i, err
}

const getPhotoById = `-- name: GetPhotoById :one
SELECT id, file_key, hash, photo_updated_at, extension
FROM photos
WHERE id = $1 AND status = 'ACTIVE'
LIMIT 1
`

type GetPhotoByIdRow struct {
	ID             uuid.UUID
	FileKey        string
	Hash           string
	PhotoUpdatedAt time.Time
	Extension      PhotoExtension
}

func (q *Queries) GetPhotoById(ctx context.Context, id uuid.UUID) (GetPhotoByIdRow, error) {
	row := q.db.QueryRow(ctx, getPhotoById, id)
	var i GetPhotoByIdRow
	err := row.Scan(
		&i.ID,
		&i.FileKey,
		&i.Hash,
		&i.PhotoUpdatedAt,
		&i.Extension,
	)
	return i, err
}

const getPhotoGroupsCount = `-- name: GetPhotoGroupsCount :one
SELECT count(1) as count FROM photo_groups
`

func (q *Queries) GetPhotoGroupsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getPhotoGroupsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getPhotoPreviews = `-- name: GetPhotoPreviews :many
SELECT id, photo_id, file_key, size_pixel, width_pixel, height_pixel, original FROM photo_previews
WHERE photo_id = $1
ORDER BY size_pixel
`

func (q *Queries) GetPhotoPreviews(ctx context.Context, photoID uuid.UUID) ([]PhotoPreview, error) {
	rows, err := q.db.Query(ctx, getPhotoPreviews, photoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PhotoPreview
	for rows.Next() {
		var i PhotoPreview
		if err := rows.Scan(
			&i.ID,
			&i.PhotoID,
			&i.FileKey,
			&i.SizePixel,
			&i.WidthPixel,
			&i.HeightPixel,
			&i.Original,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPhotoProcessing = `-- name: GetPhotoProcessing :many
SELECT photo_id, processed_at, type, success FROM photo_processing
WHERE photo_id=$1
ORDER BY processed_at
`

func (q *Queries) GetPhotoProcessing(ctx context.Context, photoID uuid.UUID) ([]PhotoProcessing, error) {
	rows, err := q.db.Query(ctx, getPhotoProcessing, photoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PhotoProcessing
	for rows.Next() {
		var i PhotoProcessing
		if err := rows.Scan(
			&i.PhotoID,
			&i.ProcessedAt,
			&i.Type,
			&i.Success,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPhotoUploadData = `-- name: GetPhotoUploadData :one
SELECT photo_id, paths, upload_at, client_info, person_id
FROM photo_upload_data
WHERE photo_id=$1
LIMIT 1
`

type GetPhotoUploadDataRow struct {
	PhotoID    uuid.UUID
	Paths      []string
	UploadAt   time.Time
	ClientInfo string
	PersonID   uuid.UUID
}

func (q *Queries) GetPhotoUploadData(ctx context.Context, photoID uuid.UUID) (GetPhotoUploadDataRow, error) {
	row := q.db.QueryRow(ctx, getPhotoUploadData, photoID)
	var i GetPhotoUploadDataRow
	err := row.Scan(
		&i.PhotoID,
		&i.Paths,
		&i.UploadAt,
		&i.ClientInfo,
		&i.PersonID,
	)
	return i, err
}

const getPhotoVector = `-- name: GetPhotoVector :one
SELECT photo_id, vector, norm FROM photo_vectors
WHERE photo_id=$1
LIMIT 1
`

func (q *Queries) GetPhotoVector(ctx context.Context, photoID uuid.UUID) (PhotoVector, error) {
	row := q.db.QueryRow(ctx, getPhotoVector, photoID)
	var i PhotoVector
	err := row.Scan(&i.PhotoID, &i.Vector, &i.Norm)
	return i, err
}

const getPhotoVectors = `-- name: GetPhotoVectors :many
SELECT photo_id, vector, norm
FROM photo_vectors
OFFSET $1
LIMIT $2
`

type GetPhotoVectorsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetPhotoVectors(ctx context.Context, arg GetPhotoVectorsParams) ([]PhotoVector, error) {
	rows, err := q.db.Query(ctx, getPhotoVectors, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PhotoVector
	for rows.Next() {
		var i PhotoVector
		if err := rows.Scan(&i.PhotoID, &i.Vector, &i.Norm); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagCategory = `-- name: GetTagCategory :one

SELECT id, type, color
FROM tag_categories
WHERE id = $1
LIMIT 1
`

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) GetTagCategory(ctx context.Context, id uuid.UUID) (TagCategory, error) {
	row := q.db.QueryRow(ctx, getTagCategory, id)
	var i TagCategory
	err := row.Scan(&i.ID, &i.Type, &i.Color)
	return i, err
}

const getTagCategoryByType = `-- name: GetTagCategoryByType :one
SELECT id, type, color
FROM tag_categories
WHERE type = $1
LIMIT 1
`

func (q *Queries) GetTagCategoryByType(ctx context.Context, type_ string) (TagCategory, error) {
	row := q.db.QueryRow(ctx, getTagCategoryByType, type_)
	var i TagCategory
	err := row.Scan(&i.ID, &i.Type, &i.Color)
	return i, err
}

const getTags = `-- name: GetTags :many
SELECT id, category_id, name FROM photo_tags
WHERE photo_id=$1
`

type GetTagsRow struct {
	ID         uuid.UUID
	CategoryID uuid.UUID
	Name       string
}

func (q *Queries) GetTags(ctx context.Context, photoID uuid.UUID) ([]GetTagsRow, error) {
	rows, err := q.db.Query(ctx, getTags, photoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsRow
	for rows.Next() {
		var i GetTagsRow
		if err := rows.Scan(&i.ID, &i.CategoryID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnprocessedPhotos = `-- name: GetUnprocessedPhotos :many
SELECT p.id FROM photos p
LEFT JOIN photo_processing ps ON p.id = ps.photo_id AND ps.type = $1
WHERE ps.photo_id is NULL and p.status = 'ACTIVE'
ORDER BY p.photo_updated_at -- TODO: Индекс на updated_at
LIMIT $2
`

type GetUnprocessedPhotosParams struct {
	Type  ProcessingType
	Limit int32
}

func (q *Queries) GetUnprocessedPhotos(ctx context.Context, arg GetUnprocessedPhotosParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getUnprocessedPhotos, arg.Type, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeNotValidPhoto = `-- name: MakeNotValidPhoto :exec
UPDATE photos SET status='NOT_VALID', error=$1 WHERE id=$2
`

type MakeNotValidPhotoParams struct {
	Error *string
	ID    uuid.UUID
}

func (q *Queries) MakeNotValidPhoto(ctx context.Context, arg MakeNotValidPhotoParams) error {
	_, err := q.db.Exec(ctx, makeNotValidPhoto, arg.Error, arg.ID)
	return err
}

const rocketLock = `-- name: RocketLock :one

INSERT INTO rocket_locks (key, locked_until) VALUES ($1, now() + $2::interval)
ON CONFLICT (key) DO UPDATE SET locked_until = (now() + $2::interval) WHERE rocket_locks.locked_until < now()
RETURNING floor(extract(epoch from locked_until))::bigint
`

type RocketLockParams struct {
	Key      string
	Interval pgtype.Interval
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) RocketLock(ctx context.Context, arg RocketLockParams) (int64, error) {
	row := q.db.QueryRow(ctx, rocketLock, arg.Key, arg.Interval)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const rocketLockDelete = `-- name: RocketLockDelete :exec
DELETE FROM rocket_locks where Key = $1 AND floor(extract(epoch from locked_until)) = $2::bigint
`

type RocketLockDeleteParams struct {
	Key string
	Ts  *int64
}

func (q *Queries) RocketLockDelete(ctx context.Context, arg RocketLockDeleteParams) error {
	_, err := q.db.Exec(ctx, rocketLockDelete, arg.Key, arg.Ts)
	return err
}

const saveApiToken = `-- name: SaveApiToken :exec
INSERT INTO api_tokens (id, person_id, caption, token, created_at, updated_at, expired_at, type)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type SaveApiTokenParams struct {
	ID        uuid.UUID
	PersonID  uuid.UUID
	Caption   string
	Token     string
	CreatedAt time.Time
	UpdatedAt time.Time
	ExpiredAt pgtype.Timestamptz
	Type      ApiTokenType
}

func (q *Queries) SaveApiToken(ctx context.Context, arg SaveApiTokenParams) error {
	_, err := q.db.Exec(ctx, saveApiToken,
		arg.ID,
		arg.PersonID,
		arg.Caption,
		arg.Token,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ExpiredAt,
		arg.Type,
	)
	return err
}

const saveCoefficientSimilarPhoto = `-- name: SaveCoefficientSimilarPhoto :exec

INSERT INTO coefficients_similar_photos (photo_id1, photo_id2, coefficient)
VALUES ($1, $2, $3)
`

type SaveCoefficientSimilarPhotoParams struct {
	PhotoId1    uuid.UUID
	PhotoId2    uuid.UUID
	Coefficient float64
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SaveCoefficientSimilarPhoto(ctx context.Context, arg SaveCoefficientSimilarPhotoParams) error {
	_, err := q.db.Exec(ctx, saveCoefficientSimilarPhoto, arg.PhotoId1, arg.PhotoId2, arg.Coefficient)
	return err
}

const saveConfirmCode = `-- name: SaveConfirmCode :exec

INSERT INTO codes (code, person_id, created_at, updated_at, active, type)
VALUES ($1, $2, $3, $4, $5, $6)
`

type SaveConfirmCodeParams struct {
	Code      string
	PersonID  uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Active    bool
	Type      CodeType
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SaveConfirmCode(ctx context.Context, arg SaveConfirmCodeParams) error {
	_, err := q.db.Exec(ctx, saveConfirmCode,
		arg.Code,
		arg.PersonID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Active,
		arg.Type,
	)
	return err
}

const saveExif = `-- name: SaveExif :exec

INSERT INTO exif_photo_data (photo_id, data)
VALUES ($1, $2)
`

type SaveExifParams struct {
	PhotoID uuid.UUID
	Data    []byte
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SaveExif(ctx context.Context, arg SaveExifParams) error {
	_, err := q.db.Exec(ctx, saveExif, arg.PhotoID, arg.Data)
	return err
}

const saveGroup = `-- name: SaveGroup :exec
INSERT INTO photo_groups (id, main_photo_id, created_at, updated_at)
VALUES ($1, $2, $3, $4)
`

type SaveGroupParams struct {
	ID          uuid.UUID
	MainPhotoID uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) SaveGroup(ctx context.Context, arg SaveGroupParams) error {
	_, err := q.db.Exec(ctx, saveGroup,
		arg.ID,
		arg.MainPhotoID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const saveMetadata = `-- name: SaveMetadata :exec

INSERT INTO meta_photo_data (photo_id, model_info, size_bytes, width_pixel, height_pixel,
                             date_time, updated_at, geo_latitude, geo_longitude)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type SaveMetadataParams struct {
	PhotoID      uuid.UUID
	ModelInfo    *string
	SizeBytes    int
	WidthPixel   int
	HeightPixel  int
	DateTime     pgtype.Timestamptz
	UpdatedAt    time.Time
	GeoLatitude  *float64
	GeoLongitude *float64
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SaveMetadata(ctx context.Context, arg SaveMetadataParams) error {
	_, err := q.db.Exec(ctx, saveMetadata,
		arg.PhotoID,
		arg.ModelInfo,
		arg.SizeBytes,
		arg.WidthPixel,
		arg.HeightPixel,
		arg.DateTime,
		arg.UpdatedAt,
		arg.GeoLatitude,
		arg.GeoLongitude,
	)
	return err
}

const savePerson = `-- name: SavePerson :exec

INSERT INTO people (id, created_at, updated_at, firstname, surname, patronymic)
VALUES ($1, $2, $3, $4, $5, $6)
`

type SavePersonParams struct {
	ID         uuid.UUID
	CreatedAt  time.Time
	UpdatedAt  time.Time
	Firstname  string
	Surname    string
	Patronymic *string
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SavePerson(ctx context.Context, arg SavePersonParams) error {
	_, err := q.db.Exec(ctx, savePerson,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Firstname,
		arg.Surname,
		arg.Patronymic,
	)
	return err
}

const savePersonAuth = `-- name: SavePersonAuth :exec

INSERT INTO auth (person_id, created_at, updated_at, email, password_hash, status, role)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type SavePersonAuthParams struct {
	PersonID     uuid.UUID
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Email        string
	PasswordHash []byte
	Status       AuthStatus
	Role         AuthRole
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SavePersonAuth(ctx context.Context, arg SavePersonAuthParams) error {
	_, err := q.db.Exec(ctx, savePersonAuth,
		arg.PersonID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Email,
		arg.PasswordHash,
		arg.Status,
		arg.Role,
	)
	return err
}

const savePhoto = `-- name: SavePhoto :exec
INSERT INTO photos (id, file_key, hash, photo_updated_at, extension, status)
VALUES ($1, $2, $3, $4, $5, 'ACTIVE')
`

type SavePhotoParams struct {
	ID             uuid.UUID
	FileKey        string
	Hash           string
	PhotoUpdatedAt time.Time
	Extension      PhotoExtension
}

func (q *Queries) SavePhoto(ctx context.Context, arg SavePhotoParams) error {
	_, err := q.db.Exec(ctx, savePhoto,
		arg.ID,
		arg.FileKey,
		arg.Hash,
		arg.PhotoUpdatedAt,
		arg.Extension,
	)
	return err
}

const savePhotoLocation = `-- name: SavePhotoLocation :exec

INSERT INTO photo_locations (photo_id, created_at, geo_latitude, geo_longitude,
                             formatted_address, street, house_number, suburb,
                             postcode, state, state_code, state_district, county,
                             country, country_code, city)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
`

type SavePhotoLocationParams struct {
	PhotoID          uuid.UUID
	CreatedAt        time.Time
	GeoLatitude      float64
	GeoLongitude     float64
	FormattedAddress string
	Street           string
	HouseNumber      string
	Suburb           string
	Postcode         string
	State            string
	StateCode        string
	StateDistrict    string
	County           string
	Country          string
	CountryCode      string
	City             string
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SavePhotoLocation(ctx context.Context, arg SavePhotoLocationParams) error {
	_, err := q.db.Exec(ctx, savePhotoLocation,
		arg.PhotoID,
		arg.CreatedAt,
		arg.GeoLatitude,
		arg.GeoLongitude,
		arg.FormattedAddress,
		arg.Street,
		arg.HouseNumber,
		arg.Suburb,
		arg.Postcode,
		arg.State,
		arg.StateCode,
		arg.StateDistrict,
		arg.County,
		arg.Country,
		arg.CountryCode,
		arg.City,
	)
	return err
}

const savePhotoPreview = `-- name: SavePhotoPreview :exec

INSERT INTO photo_previews (id, photo_id, file_key, size_pixel, width_pixel, height_pixel, original)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type SavePhotoPreviewParams struct {
	ID          uuid.UUID
	PhotoID     uuid.UUID
	FileKey     string
	SizePixel   int
	WidthPixel  int
	HeightPixel int
	Original    bool
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SavePhotoPreview(ctx context.Context, arg SavePhotoPreviewParams) error {
	_, err := q.db.Exec(ctx, savePhotoPreview,
		arg.ID,
		arg.PhotoID,
		arg.FileKey,
		arg.SizePixel,
		arg.WidthPixel,
		arg.HeightPixel,
		arg.Original,
	)
	return err
}

const savePhotoUploadData = `-- name: SavePhotoUploadData :exec

INSERT INTO photo_upload_data (photo_id, paths, upload_at, client_info, person_id)
VALUES ($1, $2, $3, $4, $5)
`

type SavePhotoUploadDataParams struct {
	PhotoID    uuid.UUID
	Paths      []string
	UploadAt   time.Time
	ClientInfo string
	PersonID   uuid.UUID
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SavePhotoUploadData(ctx context.Context, arg SavePhotoUploadDataParams) error {
	_, err := q.db.Exec(ctx, savePhotoUploadData,
		arg.PhotoID,
		arg.Paths,
		arg.UploadAt,
		arg.ClientInfo,
		arg.PersonID,
	)
	return err
}

const savePhotoVector = `-- name: SavePhotoVector :exec

INSERT INTO photo_vectors (photo_id, vector, norm)
VALUES ($1, $2, $3)
`

type SavePhotoVectorParams struct {
	PhotoID uuid.UUID
	Vector  []float64
	Norm    float64
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SavePhotoVector(ctx context.Context, arg SavePhotoVectorParams) error {
	_, err := q.db.Exec(ctx, savePhotoVector, arg.PhotoID, arg.Vector, arg.Norm)
	return err
}

const saveRefreshToken = `-- name: SaveRefreshToken :exec

INSERT INTO refresh_codes (id, person_id, created_at, updated_at, status)
VALUES ($1, $2, $3, $4, $5)
`

type SaveRefreshTokenParams struct {
	ID        uuid.UUID
	PersonID  uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	Status    RefreshTokenStatus
}

// ----------------------------------------------------------------------------------------------------------------------
func (q *Queries) SaveRefreshToken(ctx context.Context, arg SaveRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, saveRefreshToken,
		arg.ID,
		arg.PersonID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Status,
	)
	return err
}

const saveTag = `-- name: SaveTag :exec
INSERT INTO photo_tags (id, category_id, photo_id, name)
VALUES ($1, $2, $3, $4)
`

type SaveTagParams struct {
	ID         uuid.UUID
	CategoryID uuid.UUID
	PhotoID    uuid.UUID
	Name       string
}

func (q *Queries) SaveTag(ctx context.Context, arg SaveTagParams) error {
	_, err := q.db.Exec(ctx, saveTag,
		arg.ID,
		arg.CategoryID,
		arg.PhotoID,
		arg.Name,
	)
	return err
}

const saveTagCategory = `-- name: SaveTagCategory :exec
INSERT INTO tag_categories (id, type, color)
VALUES ($1, $2, $3)
`

type SaveTagCategoryParams struct {
	ID    uuid.UUID
	Type  string
	Color string
}

func (q *Queries) SaveTagCategory(ctx context.Context, arg SaveTagCategoryParams) error {
	_, err := q.db.Exec(ctx, saveTagCategory, arg.ID, arg.Type, arg.Color)
	return err
}

const setPhotoGroupMainPhoto = `-- name: SetPhotoGroupMainPhoto :exec
UPDATE photo_groups
SET main_photo_id = $1, updated_at = $2
WHERE id = $3
`

type SetPhotoGroupMainPhotoParams struct {
	MainPhotoID uuid.UUID
	UpdatedAt   time.Time
	ID          uuid.UUID
}

func (q *Queries) SetPhotoGroupMainPhoto(ctx context.Context, arg SetPhotoGroupMainPhotoParams) error {
	_, err := q.db.Exec(ctx, setPhotoGroupMainPhoto, arg.MainPhotoID, arg.UpdatedAt, arg.ID)
	return err
}

const updateRefreshTokenStatus = `-- name: UpdateRefreshTokenStatus :exec
UPDATE refresh_codes
SET status = $1, updated_at = $2
WHERE id = $3
`

type UpdateRefreshTokenStatusParams struct {
	Status    RefreshTokenStatus
	UpdatedAt time.Time
	ID        uuid.UUID
}

func (q *Queries) UpdateRefreshTokenStatus(ctx context.Context, arg UpdateRefreshTokenStatusParams) error {
	_, err := q.db.Exec(ctx, updateRefreshTokenStatus, arg.Status, arg.UpdatedAt, arg.ID)
	return err
}
